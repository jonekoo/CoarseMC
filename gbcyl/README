


PTGBCYL USER MANUAL
-------------------

Jouni Karjalainen
jouni.m.karjalainen@gmail.com



Introduction
------------

This is PTGBCYL, a Monte Carlo simulation package for coarse-grained
molecular models. The copyright belongs to Jouni Karjalainen for most
of the code. See LICENSE for licensing. Some included libraries, modules
or subroutines have different licensing. Where appropriate, these are
documented in the source files. 



Building
---------

Requirements:

The package does not provide pre-built binaries, hence a fairly recent
Fortran compiler with MPI library wrappers is required. The program has
been successfully compiled using Gnu Compiler Collection (GCC) 6.0.0
with OpenMPI 1.10.0, as well as Intel Parallel Studio XE versions 2015
and 2016, with Intel MPI 5.0.1 and 5.1.1, respectively. Older versions
of the compilers may lack support for some Fortran 2003/2008 features
used in the program. A C compiler is also needed to compile the included
Cephes library. A POSIX-compliant Bourne-shell-like environment is
expected in the build process, but not necessary. Python 2.7 with the
ujson module (https://pypi.python.org/pypi/ujson) installed is
recommended to run the scripts used to edit input/output files.


Examples:

Here we assume that the MPI wrappers for your Fortran and C compilers
are called mpif90 and mpicc, respectively.

The top folder of the package contains the script configure to configure
the package before building it with make. Here are examples of
configuring and building the package with GNU and Intel compilers:
 
GCC:
./configure --prefix=yourinstallationpath FC=mpif90 \
FCFLAGS="-fno-range-check -O2 -fopenmp" CC=mpicc CFLAGS="-O2 -fopenmp" \
F77=mpif90 FFLAGS="-O2 -fopenmp"
make

Intel:
./configure --prefix=yourinstallationpath FC=mpif90 \
FCFLAGS="-standard-semantics -O2 -openmp" CC=mpicc CFLAGS="-O2 -openmp" \
F77=mpif90 FFLAGS="-O2 -openmp" 
make

Note that the compiler flags "-standard-semantics" (Intel) and
"-fno-range-check" (GNU) are mandatory. The --prefix option is
optional and needed only if you want to install the binaries with

make install

To see more configuration options, use command
./configure --help

VPATH builds are supported so that one can do in the top directory for example:
mkdir build
cd build
../configure [the options as listed above]
make



Optimization:

Interprocedural optimization (IPO) is highly recommended to reduce the
run time! For Intel Fortran the compiler/linker options is -ipo. With
this option one must also set the linker and archiver to the Intel xild
and xiar as follows:

./configure --prefix=yourinstallationpath FC=mpif90 \
FCFLAGS="-standard-semantics -O2 -ipo" CC=mpicc CFLAGS="-O2" F77=mpif90 \
FFLAGS="-O2" LD=xild AR=xiar

After the configure step you may have to compile the mt_stream_f90-1.11
library separately without IPO:

cd mt_stream_f90-1.11
make FCFLAGS=[your options without the interprocedural optimization] 
cd ..

(and then in the top directory run)
make



Usage
-----

Input:

As a minimum requirement to run a simulation the program needs a single
input file. The input file contains the combination of simulation and
interaction parameters, particle coordinates and the simulation box
geometry. This combination is (from hereon) called a snapshot.
PTGBCYL snapshots are written in JavaScript Object Notation (JSON).
The distribution contains example input files in the folder Examples.

Each replica in a parallel tempering simulation needs a separate input
file with a temperature different from others. This makes the input
files somewhat superfluous, but it is fairly simple for the user to
multiply and edit inputs starting with a single file and using e.g. the
included Python script update_json.py. The Examples folder contains
sample input files and directions on how to use them.

By default, for a simulation with N replicas, ptgbcyl will look for files
named input-0.json, input-1.json, etc. in the directory the program is
run.

The distribution contains the program create_crystal for creating a 
hexagonally tight-packed crystal configuration of either point or rod-type
particles. Instructions on usage are given by calling the program with 

./create_crystal --help

 

Running the simulation:

The MC moves are performed in sweeps. A single sweep includes trial move
of each particle in a sequence. In the NPT ensemble, the particle moves
are followed by trial volume scaling(s). If possible, domain
decomposition is used to divide work to several OpenMP threads. If the
number of MPI processes is greater than one, trial swaps of temperature
with the parallel tempering algorithm are performed every pt_period:th
sweep.

In normal operation, ptgbcyl performs the following tasks

1) Read particles, interactions and simulation control parameters from
   input and initialize.
2) Run n_equilibration_sweeps + n_production_sweeps MC sweeps.

Periodic tasks between sweeps include: 
   - Record snapshots.
   - Update restart files.
   - Adjust moves. (During the first n_equilibration_sweeps)

Example command of running a parallel tempering simulation with 8
replicas, one per MPI process, and two OpenMP threads per each replica
for domain decomposition:

export OMP_NUM_THREADS=2
mpirun -np 8 ./ptgbcyl -i ptgbcyl-_I_.json

The "_I_" is a special string, which is substituted with the MPI process
id by the program. Here, the input is contained in the files
ptgbcyl-in-0.json,..., ptgbcyl-in-7.json. The specific command
(mpirun/srun/aprun/...) to run the program will depend on the platform
you are working on.

The program will periodically output files restart-0.json,
restart-1.json, etc., which can be used to restart the simulation. It
will also periodically record particle coordinates and simulation
parameters to files output-0.json, output-1.json, etc. The name of the
restart and output files can be defined similarly as the input file with
options -r and -o, respectively:

mpirun -np 2 ./ptgbcyl -i myinputfile-_I_.json -r myrestartfile-_I_.json \
-o myoutputfile-_I_.json



Output:

During the simulation, each MPI process/parallel tempering replica
outputs snapshots to its own data file. By default the file is called
output-_I_.json, where _I_ is the replica index. The interval of
collecting snapshots can be set with the parameter production_period.

The output files are meant for storing the results from the simulations
for post-processing and analysis. At the end of the simulation, the
output file contains a sequence of snapshots, which are valid JSON
objects in the same format as in the input files. The file as a whole is
not JSON, though, since the objects themselves are not contained in a
list or a JSON object.

In addition to the data files, program also outputs checkpoint/restart
files, which are by default named restart-_I_.json. Here, _I_ is again the
id of the MPI process. The content and format of the files matches the
input files, complemented with any default parameters that were assumed
by program. The checkpoint files can be used to quickly restart/continue an
interrupted simulation.

The interval at which the restart files are updated can be set with the
parameter restartperiod. The restart files are always replaced with
the new files. Note that it is also possible to pick snapshots from the
output files for restarting but this is not always convenient. Restart
files also save storage space if one wants frequent checkpointing but
does not want to collect snapshots, e.g. during a long thermalization
run.



Processing the results
----------------------

A common task is to analyze some property at a single, constant
temperature. If parallel tempering moves have been applied, one may have
to collect data from multiple files to get all the results at a single
temperature. If necessary, the output can be sorted by temperature with
the Python script Python script reorder_output.py included in the package:

python reorder_output.py output-*.json

will produce files sorted-0.json sorted-1.json,... The files are in the
order of ascending temperature and contain correct JSON. Note that the
sorting can take from a few minutes to a few hours, depending on the
amount of data and the Python version/modules. Python 2.7 with the ujson
module is recommended.



Package folders (in alphabetical order)
---------------------------------------

BLAS:
Basic Linear Algebra Subprograms. Used by some of the analysis
tools.

cephes:
Mathematical library of special functions. Used by the ljwall_interaction.

claf90:
Library for command-line parsing. Used by the main program.

doxygen-doc:
Created if doxygen is available

Examples:
Contains example input files for simulations.

lapack:
Linear Algebra PACKage. Used by some of the analysis tools.

mt_stream_f90-1.11:
Multiple Stream Mersenne Twister Pseudo-Random Number Generator

src:
The program source code and accompanied scripts for processing input and
output files



